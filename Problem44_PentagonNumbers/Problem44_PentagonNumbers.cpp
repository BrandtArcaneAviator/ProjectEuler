/*
Program to find the pair of pentagonal numbers,
P_j, P_k, for which their sum and difference
are pentagonal and their difference
( D = P_k - P_j ) is minimized (noting that
we want to also report the value of D).

Note pentagonal numbers are generated by:
	P_n = n ( 3n - 1 ) / 2
such that the first ten pentagonal numbers are:
	1, 5, 12, 22, 35, 51, 70, 92, 117, 145...
Notably, their sums and differences can equal
other pentagonal numbers (e.g. 
P_4 + P_7 = 22 + 70 = 92 = P_8).

Here, we want to find a pair of numbers
that satisfy:
	1) Are pentagonal numbers.  Thus, we
	   can use the above equation to determine
	   all the numbers we consider.
	2) Their sum is pentagonal (Pj + Pk = A).
	3) Their difference is pentagonal (Pk - Pj = D).
	4) Their difference (D) is minimized in value.
Thus, for 2) and 3), we need to be able to identify
if a number is pentagonal.  Since we only deal with
pentagonal values period as a result here, it makes
sense to create a database (a vector) of pentagonal
values to check against.  Note then that for a
given range of pentagonal numbers (from n=1 to a max
n value), we can use if conditions to algorithmically
find sums and differences that are pentagonal (i.e.
A and D exist in that vector).  After finding D 
values that are pentagonal, we can search among those
for a minimum value (using min_element() from <algorithm>).
*/

#include <algorithm> // for min_element().
#include <cstdint> // For large int types.
#include <iostream>
#include <vector>

using largeint_t = int_fast64_t;

/* Function to generate a pentagonal number: */
largeint_t calculatePentagNumN(const largeint_t& n)
{
	return ((n * ((3 * n) - 1) )/ 2); // Note the integer division concern here.
}


/* Boolean function to check whether the sum
   of two pentagonal numbers exists in the
   pentagonal database vector: */
bool checkPentagonSum(const std::vector<largeint_t>& pentVec, const largeint_t& pj, const largeint_t& pk)
{
	for (largeint_t pent : pentVec)
	{
		// If sum exists in pentVec, return true.
		if ((pj + pk) == pent)
		{
			return true;
		}
	}
	// Otherwise, return false:
	return false;
}


/* Boolean function to check whether the difference
   of two pentagonal numbers exists in the
   pentagonal database vector: */
bool checkPentagonDiff(const std::vector<largeint_t>& pentVec, const largeint_t& pj, const largeint_t& pk)
{
	for (largeint_t pent : pentVec)
	{
		/* If diff exists in pentVec, return true. */
		if ((pk - pj) == pent)
		{
			return true;
		}
	}
	// Otherwise, return false:
	return false;
}

int main()
{
	/*
	Ask for the bounds of n to check for 
	minimum pentagonal D:  Note that this
	allows the user to narrow into ranges,
	such that if one doesn't find a valid
	answer for 1 <= n <= maxN, e.g., they
	can now look for maxN <= n <= newMaxN.
	*/
	std::cout << "Enter the minimum value of n for generating pentagonal numbers (start with 1 if unsure): ";
	largeint_t minN{};
	std::cin >> minN;

	std::cout << "Enter the maximum value of n for generating pentagonal numbers: ";
	largeint_t maxN{};
	std::cin >> maxN;

	/*
	Generate a database of pentagonal values up
	to the max value of n:
	*/
	std::vector<largeint_t> pentagonValues{};

	for (largeint_t i{ minN }; i <= maxN; ++i)
	{
		pentagonValues.push_back( calculatePentagNumN(i) );
	}
	/* DEBUG: Print this vector:
	for (largeint_t a : pentagonValues)
	{
		std::cout << a << ", ";
	}
	std::cout << '\n'; */
	
	
	/*
	Now we need to sweep sums and differences in this
	vector database and check for pentagonal values, and
	record the difference values for such pairs:
	*/
	std::vector<largeint_t> pentDiffValues{};
	std::vector<std::vector<largeint_t>> pentDiffPairs{};
	std::vector<largeint_t> tempPair{};
	tempPair.resize(2);

	for (largeint_t pj : pentagonValues)
	{
		for (largeint_t pk : pentagonValues)
		{
			// Skips repeat values, ensures D is positive.
			if (pk > pj)
			{
				/* If both the sum and diff of Pj, Pk in
				range are pentagonal: */
				/* && checkPentagonDiff(pentagonValues, pj, pk) */
				if (checkPentagonSum(pentagonValues, pj, pk) && checkPentagonDiff(pentagonValues, pj, pk))
				{
					// Record the difference value:
					pentDiffValues.push_back((pk - pj));

					// And record the relevant pair for that D:
					tempPair.at(0) = pj;
					tempPair.at(1) = pk;
					pentDiffPairs.push_back(tempPair);
				}
			}
		}
	}

	/*
	Now we have a vector of all difference values
	satisfying conditions 1)-3).  For the final
	condition 4), we use min_element() to search
	this vector for the smallest value of D,
	and then report that D value and its associated
	pair:
	*/

	// If we find no valid D values, report this:
	if (pentDiffValues.empty())
	{
		std::cout << "No valid pentagonal differences were found in the range "
			<< minN << " <= n <= " << maxN << ".\n";
	}
	else // We have valid D values:
	{
		largeint_t minDposition{ std::distance(pentDiffValues.begin(), std::min_element(pentDiffValues.begin(), pentDiffValues.end())) };

		std::cout << "The minimum pentagonal difference was found to be "
			<< pentDiffValues.at(minDposition) << " for the pair ("
			<< pentDiffPairs.at(minDposition).at(0) << ", "
			<< pentDiffPairs.at(minDposition).at(1)
			<< ") for the range of " << minN << " <= n <= " << maxN << ".\n";
	}

	return 0;
}