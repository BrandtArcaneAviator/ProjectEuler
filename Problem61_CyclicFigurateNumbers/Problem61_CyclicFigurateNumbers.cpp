/*
Program to calculate the sum of the only
ordered set of six cyclic 4-digit numbers
for which each polygonal type (triangular,
square, pentagonal, hexagonal, heptagonal,
and octagonal) is represented by a different
number in the set.

Notably, each polygonal type is generated by
an associated equation:
	Triangle: P_3_n = n (n + 1) / 2
	Square: P_4_n = n^2
	Pentagonal: P_5_n = n (3n - 1) / 2
	Hexagonal: P_6_n = n (2n - 1)
	Heptagonal: P_7_n = n (5n - 3) / 2
	Octagonal: P_8_n = n (3n - 2)

Now, as to the set of numbers and their ordering,
note the following rules:
	1) The set is cylic, in that the last two digits
	of each number is the first two digits of the next
	number (note this loops around from the last number
	in the set to the first number in the set).
	2) Each polygonal type is represented by a different
	number in the set, as noted above.
	3) This set is unique (is the only set of 4-digit
	numbers with this property).

For a similar example, note that for triangular, square,
and pentagonal numbers we have the set (8128, 2882, 8281)
that follows this setup.

To identify the unique set of six 4-digit numbers, first
let's recognize that we only need to look at a) 4-digit
numbers (i.e. the range 1000 - 9999) that b) follow the
digit matching property described in 1) above. Therefore,
e.g. we only want numbers in the set that follow the
pattern, e.g., 1010, 1011, 1112, 1213, 1314, etc.  Since
all the numbers in the set must be of different polygonal
types, it then makes sense to use the following algorithm:
	i) Use the polygonal equations to find a triangular (e.g.)
	   value and a square value.
	ii) If the square value does not have the last two digits
	   of the triangular value as it first digits, repeat i)
	   for different values.
	iii) If ii) is true, then record those values and move
	   to the next pentagonal type and repeat ii) for the
	   new type.
	iv) Repeat i-iii) until we have one number for each type
	   that satisfies the cyclic property.
	v) IF we run into the issue that there isn't a number
	   following this cycle (e.g. we run all possible
	   pentagonal numbers for a given set up to that point
	   but find no numbers that match the cyclic property),
	   then we MUST reset back to step i) for the next potential
	   triangular-square pair.
Note, though, that it may be possible that the polygonal numbers
are NOT ordered by their polygonal types, so we should also be
checking permutations of their ordering (keeping the changing
digits this implies in mind for the next number in the series).
Therefore, in ii), we should also check whether a permutation of
the current numbers is possible and whether this new permutation
allows for a new number.

Also, note that we'll need to be able to identify and extract
the first and last two digits of 4-digit numbers for comparison
(using a function) and to generate numbers according to polygonal type
(using a single function with a switch in it in association with an 
enum class).  Note we can adapt the function from problem 52 for
extracting digits to vectors.

Furthermore, recall that we only care about 4-digit numbers.
We thus need to bound all types of polygonal numbers to their largest 
and smallest n value that produce their largest and smallest 4-digit
values.  We can determine this using the inverse equations for each 
polygonal type (noting we only care about values that give whole n 
integers) for polygonal numbers near (but above) 1000 and near 
(but below) 9999.  If we do this (shown as debug code here), we get:
	Triangular 4-digit bounds: 45 <= n <= 140 
	Square 4-digit bounds: 32 <= n <= 99 
	Pentagonal 4-digit bounds: 26 <= n <= 81
	Hexagonal 4-digit bounds: 23 <= n <= 70
	Heptagonal 4-digit bounds: 21 <= n <= 63
	Octagonal 4-digit bounds: 19 <= n <= 58
*/

#include <algorithm> // for next_permutation()
#include <cstdint>
#include <iostream>
#include <sstream> // for stringstream.
#include <vector>


using lint_t = int_fast32_t;


/* Enum class for polygonal number type: */
enum class PolygonalType
{
	triangular,
	square,
	pentagonal,
	hexagonal,
	heptagonal,
	octagonal,
	max_polygonaltypes
};


/* Function to generate polygonal numbers according
to the selected PolygonalType parameter: */
lint_t calculatePolygonalValue(const lint_t& n, const PolygonalType& poly)
{
	switch (poly)
	{
	case PolygonalType::triangular:
		return ((n * (n + 1)) / 2);
		break;
	case PolygonalType::square:
		return (n*n);
		break;
	case PolygonalType::pentagonal:
		return ((n * (3*n - 1)) / 2);
		break;
	case PolygonalType::hexagonal:
		return (n * (2*n - 1));
		break;
	case PolygonalType::heptagonal:
		return ((n * (5*n - 3)) / 2);
		break;
	case PolygonalType::octagonal:
		return (n * (3*n - 2));
		break;
	default: return 0;
	}
}


/* Function to extract digits of an int value
into a vector: */
std::vector<int> extractDigitstoVec(const lint_t& val)
{
	std::stringstream valSS{};
	valSS << val;
	std::string valStr{};
	valSS >> valStr;

	std::vector<int> valVec{};

	for (int it{ 0 }; it < static_cast<int>(valStr.length()); ++it)
	{
		/* Requires an implict type-cast from char to int,
		hence the - '0'. */
		valVec.push_back(valStr[it] - '0');
	}

	return valVec;
}

/* Boolean function to check the last two digits of one 4-digit
value against the first two digits in another. Returns true if
they are the same, false otherwise.  Should not be used on
values less than 1000 (i.e. sub 4-digit numbers) as this will
cause an out-of-bounds error! */
bool checkCyclicPair4digit(const lint_t& val1, const lint_t& val2)
{
	/* Extract digits for comparison: */
	std::vector<int> vec1{ extractDigitstoVec(val1) };
	std::vector<int> vec2{ extractDigitstoVec(val2) };

	/* Compare last two digits of val1 (.at(2) and .at(3)) against
	first two digits of val2 (.at(0) and .at(1): */
	if (vec1.at(2) == vec2.at(0) && vec1.at(3) == vec2.at(1))
		return true;
	else
		return false;
}


/* Debug function determining the bounds 
of n for each polygonal type. Returns -1 if number
does not return a valid n for the given polygonal type. */
/* lint_t calculateNfromVal(const lint_t& val, const PolygonalType& poly)
{
	double result{};

	switch (poly)
	{
	case PolygonalType::triangular:
		result = ((sqrt(8 * val + 1) - 1) / 2);
		if (floor(result) == result)
			return result;
		else
			return -1;
	case PolygonalType::square:
		result = sqrt(val);
		if (floor(result) == result)
			return result;
		else
			return -1;
	case PolygonalType::pentagonal:
		result = ((sqrt(24 * val + 1) + 1) / 6);
		if (floor(result) == result)
			return result;
		else
			return -1;
	case PolygonalType::hexagonal:
		result = ((sqrt(32 * val + 4) + 2) / 8);
		if (floor(result) == result)
			return result;
		else
			return -1;
	case PolygonalType::heptagonal:
		result = ((sqrt(40 * val + 9) + 3) / 10);
		if (floor(result) == result)
			return result;
		else
			return -1;
	case PolygonalType::octagonal:
		result = ((sqrt(48 * val + 16) + 4) / 12);
		if (floor(result) == result)
			return result;
		else
			return -1;
	default: return -1;
	}
} */


int main()
{
	/*
	DEBUG:
	Determine the bounds of n for 4-digit nums (1000-9999)
	for each polygonal type:
	*/
	/* std::cout << "Enter the polygonal type (0=tri, 1=square, 2=pent, 3=hex, 4=hept, 5=oct): ";
	int polytypeint{};
	std::cin >> polytypeint;
	PolygonalType polyType{ static_cast<PolygonalType>(polytypeint) }; */

		/* Find lower bound of this: */
	/* lint_t polyn1{};
	
	for (lint_t value{1000}; value<=9999; ++value)
	{
		/* If we get a valid n, its the first valid n in range: */
		/*if (calculateNfromVal(value, polyType) != -1)
		{
			polyn1 = calculateNfromVal(value, polyType);
			break;
		}
	} */

		/* Find upper bound of this: */
	/* lint_t polyn2{};

	for (lint_t value{ 9999 }; value >= 1000; --value)
	{ */
		/* If we get a valid n, its the last valid n in range: */
		/* if (calculateNfromVal(value, polyType) != -1)
		{
			polyn2 = calculateNfromVal(value, polyType);
			break;
		}
	}

	std::cout << "For type " << static_cast<int>(polyType) << ", we have the range "
		<< polyn1 << " <= n <= " << polyn2 << ".\n"; */



	/* Initialize a vector to contain the set of numbers: */
	std::vector<lint_t> cyclicSet{};
	cyclicSet.resize( 6 );

	lint_t tempTri{ 0 };
	lint_t tempSquare{ 0 };
	lint_t tempPent{ 0 };
	lint_t tempHex{ 0 };
	lint_t tempHept{ 0 };
	lint_t tempOct{ 0 };

	bool setisFound{ false };


	///* For loops for polygonal values: */
	//for (lint_t trin{ 45 }; trin <= 140; ++trin) 
	//{
	//	tempTri = calculatePolygonalValue(trin, PolygonalType::triangular);

	//	for (lint_t squaren{ 32 }; squaren <= 99; ++squaren) 
	//	{
	//		tempSquare = calculatePolygonalValue(squaren, PolygonalType::square);

	//		if (checkCyclicPair4digit(tempTri, tempSquare))
	//		{
	//			/* If true, move to next polygonal number: */
	//			for (lint_t pentn{ 26 }; pentn <= 81; ++pentn)
	//			{
	//				tempPent = calculatePolygonalValue(pentn, PolygonalType::pentagonal);

	//				if (checkCyclicPair4digit(tempSquare, tempPent))
	//				{
	//					for (lint_t hexn{ 23 }; hexn <= 70; ++hexn)
	//					{
	//						tempHex = calculatePolygonalValue(hexn, PolygonalType::hexagonal);

	//						if (checkCyclicPair4digit(tempPent, tempHex))
	//						{
	//							for (lint_t heptn{21}; heptn <= 63; ++heptn)
	//							{
	//								tempHept = calculatePolygonalValue(heptn, PolygonalType::heptagonal);

	//								if (checkCyclicPair4digit(tempHex, tempHept))
	//								{
	//									for (lint_t octn{19}; octn <= 58; ++octn)
	//									{
	//										tempOct = calculatePolygonalValue(octn, PolygonalType::octagonal);

	//										/* For last element in cycle, also check against first element: */
	//										if (checkCyclicPair4digit(tempHept, tempOct) && checkCyclicPair4digit(tempOct, tempTri))
	//										{
	//											/* If true, we've found the set so record it: */
	//											cyclicSet.at(0) = tempTri;
	//											cyclicSet.at(1) = tempSquare;
	//											cyclicSet.at(2) = tempPent;
	//											cyclicSet.at(3) = tempHex;
	//											cyclicSet.at(4) = tempHept;
	//											cyclicSet.at(5) = tempOct;
	//											setisFound = true;
	//										}

	//										if (setisFound)
	//										{
	//											break;
	//										}
	//									}
	//								}
	//								
	//								if (setisFound)
	//								{
	//									break;
	//								}
	//							}
	//						}
	//						
	//						if (setisFound)
	//						{
	//							break;
	//						}
	//					}
	//				}
	//				
	//				if (setisFound)
	//				{
	//					break;
	//				}
	//			}
	//		}
	//		
	//		if (setisFound)
	//		{
	//			break;
	//		}
	//	}

	//	if (setisFound)
	//	{
	//		break;
	//	}
	//}


	/* Alternate method including various permutations: */
	for (lint_t trin{ 45 }; trin <= 140; ++trin)
	{
		tempTri = calculatePolygonalValue(trin, PolygonalType::triangular);

		for (lint_t squaren{ 32 }; squaren <= 99; ++squaren)
		{
			tempSquare = calculatePolygonalValue(squaren, PolygonalType::square);

			for (lint_t pentn{ 26 }; pentn <= 81; ++pentn)
			{
				tempPent = calculatePolygonalValue(pentn, PolygonalType::pentagonal);

				for (lint_t hexn{ 23 }; hexn <= 70; ++hexn)
				{
					tempHex = calculatePolygonalValue(hexn, PolygonalType::hexagonal);

					for (lint_t heptn{ 21 }; heptn <= 63; ++heptn)
					{
						tempHept = calculatePolygonalValue(heptn, PolygonalType::heptagonal);

						for (lint_t octn{ 19 }; octn <= 58; ++octn)
						{
							tempOct = calculatePolygonalValue(octn, PolygonalType::octagonal);

							/* Now we set up a permutation: */
							cyclicSet.at(0) = tempTri;
							cyclicSet.at(1) = tempSquare;
							cyclicSet.at(2) = tempPent;
							cyclicSet.at(3) = tempHex;
							cyclicSet.at(4) = tempHept;
							cyclicSet.at(5) = tempOct;

							/* Now check this and all other possible permuations: */
							do
							{
								if (checkCyclicPair4digit(cyclicSet.at(0), cyclicSet.at(1)))
								{
									if (checkCyclicPair4digit(cyclicSet.at(1), cyclicSet.at(2)))
									{
										if (checkCyclicPair4digit(cyclicSet.at(2), cyclicSet.at(3)))
										{
											if (checkCyclicPair4digit(cyclicSet.at(3), cyclicSet.at(4)))
											{
												if (checkCyclicPair4digit(cyclicSet.at(4), cyclicSet.at(5)))
												{
													if (checkCyclicPair4digit(cyclicSet.at(5), cyclicSet.at(0)))
													{
														setisFound = true;
														break;
													}
												}
											}
										}
									}
								}
							} while (std::next_permutation(cyclicSet.begin(), cyclicSet.end()));

							if (setisFound)
							{
								break;
							}
						}

						if (setisFound)
						{
							break;
						}
					}

					if (setisFound)
					{
						break;
					}
				}

				if (setisFound)
				{
					break;
				}
			}

			if (setisFound)
			{
				break;
			}
		}

		if (setisFound)
		{
			break;
		}
	}


	/* DEBUG: Print the set of numbers: */
	std::cout << "( ";
	for (lint_t it2{0}; it2 < cyclicSet.size(); ++it2)
	{
		if (it2 != (cyclicSet.size() - 1))
			std::cout << cyclicSet.at(it2) << ", ";
		else
			std::cout << cyclicSet.at(it2);
	}
	std::cout << ")\n";

	/* Now return the sum of these numbers to the user: */
	lint_t totalSum{ 0 };

	for (lint_t b : cyclicSet)
	{
		totalSum += b;
	}

	std::cout << "The sum of all cyclic numbers in the "
		<< "polygonal set (Tri, Square, Pent, Hex, Hept, Oct) yields "
		<< totalSum << ".\n";
	

	return 0;
}